# # 设计模式学习总结

**设计模式学习总结**
## 设计模式
### 1、设计模式基本原则
1、开闭原则：对扩展开放，对修改关闭。

2、单一职责原则：修改一个类的理由永远不要超过一个。一个类是不是不能再精简代码了，而不是还能不能扩充。

3、接口隔离原则：细化接口，每一个接口应该是一种角色，不多不少，不干不该干的事，该干的事都要干。

4、里氏替换原则：所有引用基类的地方必须能够被其子类替换而不会产生异常。

5、迪米特法则：

6、依赖反转原则：抽象不应该依赖于细节，细节应当依赖于抽象。要针对接口编程，而不是针对实现编程。尽量引用高层次的类。

7、组合复用原则。


###  2、设计模式分类
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br>
(1)创造型模式：<br>
简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，单例模式，原型模式。<br>
(2)结构性模式：<br>
适配器模式，代理模式，装饰器模式，组合模式，门面模式，享元模式，桥接模式。<br>
(3)行为性模式：<br>
策略模式，访问者模式，观察者模式，中介模式，责任链模式，备忘录模式，命令模式，模板方法模式，解释器模式

### 3、常见设计模式总结
(1)工厂模式：对象的创建与使用分离，达到解耦的目的。封装对象的创建过程，屏蔽对象创建过程的变化，达到可扩展的目的。<br>
(2)建造者模式：<br>
建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。<br>
为了灵活构造复杂对象，该对象会有多个成员变量，在外部调用的时候，不需要或者不方便一次性创建出所有的成员变量，在这种情况下，使用多个构造方法去构建对象，很难维护，这时候Builder设计模式解决这个问题，进行buid()方法中创建对象，并且将builder传入，该builder中，维护了传入对象的成员变量<br>
(3) 策略模式<br>
策略模式的定义如下：定义一系列算法，将每个算法都封装起来，并且它们可以互换。策略模式是一种对象行为模式。<br>
(4)责任链模式<br>
模式定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。<br>
(5)通过近实时的指标，监控和告警，确保故障被及时发现<br>
(6)通过动态修改配置属性，确保故障及时恢复<br>
(7)防止整个依赖客户端执行失败，而不仅仅是网络通信<br>
### 4、代理模式和装饰器模式区别
(1)目的性不同，代理是控制和新增语义，装饰是加强语义；<br>
(2)在编译上代理模式不要求同源，装饰器模式要求同源；<br>
(3) 实现上有点区别，代理一般就一层，装饰器一般都会嵌套；<br>
(4)一般情况下，是否被代理，决定权在接口的提供方，是否需要装饰，决定权在接口的调用方；<br>
(5)；<br>
(6)执行 HystrixObservableCommand.construct() 或HystrixCommand.run()，如果执行失败或者超时，跳到第8步；否则，跳到第9步；<br>
(7)统计熔断器监控指标；<br>
(8)走Fallback备用逻辑；<br>
(9)返回请求响应。
从流程图上可知道，第5步线程池/队列/信号量已满时，还会执行第7步逻辑，更新熔断器统计信息，而第6步无论成功与否，都会更新熔断器统计信息。
### 5、Hystrix 执行命令的几种方法
Hystrix 提供了4种执行命令的方法，execute() 和 queue() 适用于 HystrixCommand 对象，而 observe() 和toObservable() 适用于 HystrixObservableCommand 对象。

execute()
以同步堵塞方式执行 run()，只支持接收一个值对象。Hystrix 会从线程池中取一个线程来执行 run()，并等待返回值。

queue()
以异步非阻塞方式执行 run()，只支持接收一个值对象。调用 queue() 就直接返回一个 Future 对象。可通过 Future.get() 拿到 run() 的返回结果，但 Future.get() 是阻塞执行的。若执行成功，Future.get() 返回单个值。当执行失败时，如果没有重写 fallback，Future.get() 抛出异常。

observe()
事件注册前执行 run() / construct()，支持接收多个值对象，取决于发射源。调用 observe() 会返回一个 hot Observable，也就是说，调用 observe() 自动触发执行 run() / construct()，无论是否存在订阅者。

如果继承的是 HystrixCommand，Hystrix 会从线程池中取一个线程以非阻塞方式执行 run()；如果继承的是HystrixObservableCommand，将以调用线程阻塞执行 construct()。

observe() 使用方法：

调用 observe() 会返回一个 Observable 对象；
调用这个 Observable 对象的 subscribe() 方法完成事件注册，从而获取结果。
toObservable()
事件注册后执行 run() / construct()，支持接收多个值对象，取决于发射源。调用 toObservable() 会返回一个 cold Observable，也就是说，调用 toObservable() 不会立即触发执行 run() / construct()，必须有订阅者订阅 Observable 时才会执行。

如果继承的是 HystrixCommand，Hystrix 会从线程池中取一个线程以非阻塞方式执行 run()，调用线程不必等待run()；如果继承的是 HystrixObservableCommand，将以调用线程堵塞执行 construct()，调用线程需等待construct() 执行完才能继续往下走。

toObservable() 使用方法：

调用 observe() 会返回一个Observable对象；
调用这个 Observable 对象的 subscribe() 方法完成事件注册，从而获取结果。
需注意的是，HystrixCommand 也支持 toObservable() 和 observe()，但是即使将 HystrixCommand 转换成Observable，它也只能发射一个值对象。只有 HystrixObservableCommand 才支持发射多个值对象。
### 5、熔断器的三种状态
Hystrix 提供的熔断器具有自我反馈，自我恢复的功能，Hystrix会根据调用接口的情况，让熔断器在closed，open，half-open 三种状态之间自动切换。<br>
open 状态：说明打开熔断，也就是服务调用方执行本地降级策略，不进行远程调用。<br>
closed 状态：说明关闭了熔断，这时候服务调用方直接发起远程调用。<br>
half-open 状态：是一个中间状态，当熔断器处于这种状态时，直接发起远程调用。<br>

**三种状态的转换：**<br>
**closed → open**：正常情况下熔断器为 closed 状态，当访问同一个接口次数超过设定阈值并且错误比例超过设置错误阈值的时候，就会打开熔断机制，这时候熔断器状态从 closed → open。

**open → half-open**：当服务接口对应的熔断器状态为 open 状态时候，所有服务调用方调用该服务方法时候都是执行本地降级方法，那么什么时候才会恢复到远程调用呢？Hystrix 提供了一种测试策略，也就是设置了一个时间窗口，从熔断器状态变为 open 状态开始的一个时间窗口内，调用该服务接口时候都委托服务降级方法进行执行。如果时间超过了时间窗口，则把熔断状态从 open → half-open，这时候服务调用方调用服务接口时，就可以发起远程调用而不再使用本地降级接口，如果发起远程调用还是失败，则重新设置熔断器状态为open状态，从新记录时间窗口开始时间。

**half-open → closed**：当熔断器状态为 half-open，这时候服务调用方调用服务接口时候，就可以发起远程调用而不再使用本地降级接口，如果发起远程调用成功，则重新设置熔断器状态为 closed 状态。

**用来判断熔断器从 closed → open:**转换的数据是 HystrixCommandMetrics 对象来做的，该对象用来存HystrixCommand 的一些指标数据，比如接口调用次数，调用接口失败的次数等等。

### 6、Hystrix 几种容错方案
**Hystrix 的容错主要有以下几种方案：**

- 隔离模式（线程池隔离、信号量隔离）
对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。
- 熔断模式
如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不再继续调用目标服务，而是调用降级服务返回数据，快速释放资源。如果目标服务情况好转则恢复调用。
- 限流模式
上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。

**隔离模式一般使用两种：**

- 线程池隔离模式<br>
使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队列慢慢处理）。
- 信号量隔离模式<br>
使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，请求来了的话，先判断计数器的数值，若超过设置的最大数值则丢弃该类型的新请求，若不超过则执行计数操作请求，使计数器 +1，请求返回则计数器 -1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量（流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务）。
### 7、 hystrix实现原理
hystrix语义为“豪猪”，具有自我保护的能力。hystrix的出现即为解决雪崩效应，它通过四个方面的机制来解决这个问题

(1)隔离（线程池隔离和信号量隔离）：限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。<br>
(2)优雅的降级机制：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。<br>
(3)熔断：当失败率达到阀值自动触发降级(如因网络故障/超时造成的失败率高)，熔断器触发的快速失败会进行快速恢复。<br>
(4)缓存：提供了请求缓存、请求合并实现。
支持实时监控、报警、控制（修改配置）

## 设计模式在项目中的实际应用

### Mybatis里设计模式的应用

####1.说明：
 Mybatis是一个使用频率较高而又设计精妙的优秀框架，同时在实现的过程中，大量用到了设计模式。
####2.建造者模式：
**概念**：将一个复杂的对象的构建与其表示分离，使得同样的构造过程可以创建不同的表示。<br>
应用示例：在mybatis的解析模块（对于配置文件解析，Mapper文件解析，注解解析）里，对于构造器的应用随处可见，通常是用于构造一个复杂的对象，使得整个对象构造过程更清晰，可灵活装配。<br>
在Mapper文件里，一个statement可以有很复杂的属性设计，通过builder的方式，对每个属性单独构造，并最终通过build()方法，来得到一个构造完成的MappedStatement 对象。当然这里不是严格按构造者模式来设计的，和标准的相比，这里缺少了Builder的接口定义，只有一个具体的Builder对象，这说明设计模式要活用活用，重要的是领悟其思想。
####3.代理模式：
**概念**： 为目标对象提供一种代理以对目标对象的访问进行控制。代理模式的设计简单，理解起来也不难。Mybatis之所以那么好用，且逐渐有取代hibernate的趋势，原因之一就是我们可以自定义SQL，同时也不需要写DB操作的实现，而只需要定义操作接口即可，接口只是定义，当其调用时，一定是通过某个实现类来完成的，而这也是mybatis设计的核心思想之一，其内部完成这个设计，正是通过代理模式来实现的，所以我们有必要在这里对这种模式进行介绍，并分析mybatis是如何设计的。<br>

**应用示例**：在mybatis里，有一个叫SqlSession的接口，该接口提供了一些数据操作的接口，并有一个默认实现DefaultSqlSession，我们定义的Mapper接口里，之所以能直接调用其方法，就是因为SqlSession的实现类为其提供了一个代理实现，其入口在getMapper，当然，不可能每个接口都定义一个代理对象，一方面接口是未知的，另一方面，也没有这个必要，所以，mybatis的是通过动态代理来实现的。其具体的类MapperProxyFactory和MapperProxy。

####3.装饰器模式：
**概念**： 允许向一个现有的对象添加新的功能，同时又不改变其结构，就增加功能来说，比继承更加灵活。装饰器模式也是一种比较常用的设计模式，在JDK的文件读写源码上，就有对装饰器模式的实际应用，这种模式在对基础功能进行扩展的场景下应用，可以起到非常好的效果。在mybatis里也应用得比较多。<br>

**应用示例**：通过这样的方式，mybatis实现根据不同的配置来构造对应的缓存的目的，而且各个属性可以自由组合，从而构造出非常灵活的缓存对象。

####3.责任链模式：
**概念**： 使很多对象都有机会处理请求，从而避免发送者与接收者之间的耦合关系。责任链模式也是一种比较常见的设计模式，应用也相当广泛，比如servlet里的的Filter就是一种典型的责任链模式。在mybatis里也有相应的应用场景。熟悉这个模式的原理和应用，其有助于我们理解mybatis的拦截器，并对数据的查询和处理做自定义的扩展。<br>
在责任链模式里，各个处理者相互之前是有关系的，即通过当前的handler可以访问到下一个，一直到最后一个handler，它们之间形成了一个链式结构。当请求来的时候，链上的handler根据条件决定是由自己处理还是交给下一个handler来处理，直到整个过程结束。<br>

**应用示例**：Mybatis里拦截器的设计是一种责任链模式的体现，不过并不是对上述模型的标准化实现，也可以认为是一个变体，其责任链的路的实现是通过拦截器接口和拦截器链来共同完成的。<br>
可见，该拦截器可以对mybatis里的三类处理器和一类执行器对象进行拦截处理，从而在必要的时候扩展或改弯这些处理器和执行器的行为，达到对mybatis数据处理功能扩展的目的。用户可以自定义拦截器，比如对于mybatis查询结果进行分页就是通过拦截器来实现的，该拦截器通过在查询时改写SQL来增加相应的分页参数，从而返回分页后的结果。这是对于拦截器的一个很经典的应用。<br>
        Mybatis的实现可以理解为是责任链模式的一个变体，这种模式又被称为是拦截器模式，但本质思路来说都是一样的。
        
####4.模板方法模式：
**概念**： 模板模式也是一种比较常见的设计模式，大体思想是基类定义主要实现，将一些功能交给子类，或者是而将一些步骤延迟到子类，这使得在不改变主体逻辑的前提下，子类又可重定义某些步骤的实现。这种设计方式我们平时用到的比较多，在mybatis里也有比较常见的应用。<br>
在责任链模式里，各个处理者相互之前是有关系的，即通过当前的handler可以访问到下一个，一直到最后一个handler，它们之间形成了一个链式结构。当请求来的时候，链上的handler根据条件决定是由自己处理还是交给下一个handler来处理，直到整个过程结束。<br>

**应用示例**：Mybatis里的Executor 使用到了模板模式，其中BaseExecutor负责大部分功能的实现，而将一些扩展由子类完成。 以更新为例，当我们执行一个update操作的时候，最终会交由Executor来执行。

