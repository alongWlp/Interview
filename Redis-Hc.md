# Redis主从高可用面试总结

**redis面试中常见问题总结**

## Redis介绍

*Redis主从，高可用，集群是面试中必不可少的面试*

## Redis持久化
## 1、Redis持久化？
redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过fork子进程执行，采用二进制压缩存储；
AOF是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。<br>
RDB把整个Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。

AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。
## Redis主从复制
## 2、主从同步原理
（1）初次连接，建立一个从服务器时， 从服务器都将向主服务器发送一个SYNC命令。接到SYNC命令的主服务器将开始执行BGSAVE， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。
（2）当 BGSAVE执行完毕后， 主服务器将执行保存操作所得的.rdb文件发送给从服务器， 从服务器接收这个.rdb文件， 并将文件中的数据载入到内存中。之后主服务器会以Redis命令协议的格式，将写命令缓冲区中积累的所有内容都发送给从服务器。<br>
（3）全部同步和部分重新同步( PSYNC)，2.8后引入了部分同步，这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）,并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset和一个主服务器ID master run id），当出现网络连接断开时,从服务器会重新连接，并且向主服务器请求继续执行原来的复制进程<br>
（4）如果从服务器记录的主服务器ID和当前要连接的主服务器的ID相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。否则的话， 从服务器就要执行完整重同步操作。

## 3、主从通信原理？

## 4、主从复制过程：
（1）从节点执行 slaveof 命令
（2）从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制
（3）从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点
（4）连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连
（5）如果主节点设置了权限，那么就需要进行权限验证；如果验证失败，复制终止。
（6）权限验证通过后，进行数据同步，这是耗时最长的操作，主节点将把所有的数据全部发送给从节点。
（7）当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。

## Redis高可用
## 2、Redis主从同步选主策略？
Redis支持主从同步，提供Cluster集群部署模式，通过Sentinel哨兵来监控Redis主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 slaveof到新主。
选主的策略简单来说有三个：
（1）slave的priority设置的越低，优先级越高；<br>
（2）同等情况下，slave复制的数据越多优先级越高；<br>
（3）相同的条件下runid越小越容易被选中。<br>
在Redis集群中，sentinel 也会进行多实例部署，sentinel之间通过Raft协议来保证自身的高可用。
RedisCluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。
## 3、Redis哨兵？
哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用。
为啥必须要三个实例呢？我们先看看两个哨兵会咋样。
master宕机了 s1和s2两个哨兵只要有一个认为你宕机了就切换了，并且会选举出一个哨兵去执行故障，但是这个时候也需要大多数哨兵都是运行的。
那这样有啥问题呢？M1宕机了，S1没挂那其实是OK的，但是整个机器都挂了呢？哨兵就只剩下S2个裸屌了，没有哨兵去允许故障转移了，虽然另外一个机器上还有R1，但是故障转移就是不执行
M1所在的机器挂了，哨兵还有两个，两个人一看他不是挂了嘛，那我们就选举一个出来执行故障转移不就好了。
哨兵组件的主要功能：
集群监控：负责监控 Redis master 和 slave 进程是否正常工作。
消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
故障转移：如果masternode 挂掉了，会自动转移到 slave node 上。
配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

## 5、为什么说Redis是单线程的以及Redis为什么这么快？
（1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；<br>
（2）数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；<br>
（3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；<br>
（4）使用多路I/O复用模型，非阻塞IO；使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中
## 6、 Redis 常见的性能问题都有哪些？如何解决？
（1）Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。<br>
（2）Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。<br>
（3）Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。<br>
（4） Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内<br>
## 7、 Redis的同步机制
Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到缓存区buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可。

