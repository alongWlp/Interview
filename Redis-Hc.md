# Redis主从高可用面试总结

**redis面试中常见问题总结**

## Redis介绍

*Redis主从，高可用，集群是面试中必不可少的面试*

## Redis持久化
## 1、Redis持久化？
redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过fork子进程执行，采用二进制压缩存储；
AOF是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。<br>
RDB把整个Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。

AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。
## Redis主从复制
## 2、主从同步原理
（1）初次连接，建立一个从服务器时， 从服务器都将向主服务器发送一个SYNC命令。接到SYNC命令的主服务器将开始执行BGSAVE， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。
（2）当 BGSAVE执行完毕后， 主服务器将执行保存操作所得的.rdb文件发送给从服务器， 从服务器接收这个.rdb文件， 并将文件中的数据载入到内存中。之后主服务器会以Redis命令协议的格式，将写命令缓冲区中积累的所有内容都发送给从服务器。<br>
（3）全部同步和部分重新同步( PSYNC)，2.8后引入了部分同步，这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）,并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset和一个主服务器ID master run id），当出现网络连接断开时,从服务器会重新连接，并且向主服务器请求继续执行原来的复制进程<br>
（4）如果从服务器记录的主服务器ID和当前要连接的主服务器的ID相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。否则的话， 从服务器就要执行完整重同步操作。

## 3、主从心跳检测？
（1）主从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过client list命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。<br>
（2）主节点默认每隔 10 秒对从节点发送 ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。<br>
（3）从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。<br>
（4）主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。

## 4、主从复制过程：
（1）从节点执行 slaveof 命令<br>
（2）从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制<br>
（3）从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点<br>
（4）连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连<br>
（5）如果主节点设置了权限，那么就需要进行权限验证；如果验证失败，复制终止。<br>
（6）权限验证通过后，进行数据同步，这是耗时最长的操作，主节点将把所有的数据全部发送给从节点。<br>
（7）当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。<br>
## 5、全量复制流程：
（1）发送 psync 命令（spync ？ -1）<br>
（2）主节点根据命令返回 FULLRESYNC <br>
（3）从节点记录主节点 ID 和 offset<br>
（4）主节点 bgsave 并保存 RDB 到本地<br>
（5）主节点发送 RBD 文件到从节点<br>
（6）从节点收到 RDB 文件并加载到内存中<br>
（7）主节点在从节点接受数据的期间，将新数据保存到“复制客户端缓冲区”，当从节点加载RDB完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）<br>
（8）从节点清空数据后加载RDB文件，如果RDB文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭.<br>
（9）从节点成功加载完RDB后，如果开启了AOF，会立刻做bgrewriteaof。

## Redis高可用
## 1、高可用保障？
Redis支持主从同步，提供Cluster集群部署模式，通过Sentinel哨兵来监控Redis主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 slaveof到新主。
选主的策略简单来说有三个：
（1）slave的priority设置的越低，优先级越高；<br>
（2）同等情况下，slave复制的数据越多优先级越高；<br>
（3）相同的条件下runid越小越容易被选中。<br>
在Redis集群中，sentinel 也会进行多实例部署，sentinel之间通过Raft协议来保证自身的高可用。
RedisCluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。
## 2、Redis哨兵？
哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用。
为啥必须要三个实例呢？我们先看看两个哨兵会咋样。
master宕机了 s1和s2两个哨兵只要有一个认为你宕机了就切换了，并且会选举出一个哨兵去执行故障，但是这个时候也需要大多数哨兵都是运行的。
那这样有啥问题呢？M1宕机了，S1没挂那其实是OK的，但是整个机器都挂了呢？哨兵就只剩下S2个裸屌了，没有哨兵去允许故障转移了，虽然另外一个机器上还有R1，但是故障转移就是不执行
M1所在的机器挂了，哨兵还有两个，两个人一看他不是挂了嘛，那我们就选举一个出来执行故障转移不就好了。<br>
哨兵组件的主要功能：<br>
集群监控：负责监控 Redis master 和 slave 进程是否正常工作。<br>
消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。<br>
故障转移：如果master node 挂掉了，会自动转移到 slave node 上。<br>
配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。<br>

## 3、哨兵(sentinel) 工作原理？
哨兵(sentinel) 是一个分布式系统,你可以在一个架构中运行多个哨兵(sentinel) 进程,这些进程使用流言协议(gossipprotocols)来接收关于Master是否下线的信息,并使用投票协议(agreement protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master.
　　每个哨兵(sentinel) 会向其它哨兵(sentinel)、master、slave定时发送消息,以确认对方是否”活”着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机” Subjective Down,简称sdown).
若“哨兵群”中的多数sentinel,都报告某一master没响应,系统才认为该master"彻底死亡"(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置.
　　虽然哨兵(sentinel) 释出为一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 --sentinel 选项来启动哨兵(sentinel).
       哨兵(sentinel) 的一些设计思路和zookeeper非常类似
## 4、 哨兵监控
  sentinel会每秒一次的频率与之前创建了命令连接的实例发送PING，包括主服务器、从服务器和sentinel实例，以此来判断当前实例的状态。down-after-milliseconds时间内PING连接无效，则将该实例视为主观下线。之后该sentinel会向其他监控同一主服务器的sentinel实例询问是否也将该服务器视为主观下线状态，当超过某quorum后将其视为客观下线状态。<br>
  当一个主服务器被某sentinel视为客观下线状态后，该sentinel会与其他sentinel协商选出领头sentinel进行故障转移工作。每个发现主服务器进入客观下线的sentinel都可以要求其他sentinel选自己为领头sentinel，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元，每个纪元中只会选择一个领头sentinel。如果所有超过一半的sentinel选举某sentinel领头sentinel。之后该sentinel进行故障转移操作。<br>
  当一个主服务器被某sentinel视为客观下线状态后，该sentinel会与其他sentinel协商选出领头sentinel进行故障转移工作。每个发现主服务器进入客观下线的sentinel都可以要求其他sentinel选自己为领头sentinel，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元，每个纪元中只会选择一个领头sentinel。如果所有超过一半的sentinel选举某sentinel领头sentinel。之后该sentinel进行故障转移操作。
## 5、故障转移
   首先是从主服务器的从服务器中选出一个从服务器作为新的主服务器。<br>
   选点的依据依次是：网络连接正常->5秒内回复过INFO命令->10*down-after-milliseconds内与主连接过的->从服务器优先级->复制偏移量->运行id较小的。<br>
   选出之后通过slaveof no one将该从服务器升为新主服务器。<br>
通过slaveof ip port命令让其他从服务器复制该信主服务器。<br>
最后当旧主重新连接后将其变为新主的从服务器。注意如果客户端与就主服务器分隔在一起，写入的数据在恢复后由于旧主会复制新主的数据会造成数据丢失。
故障转移成功后会通过发布订阅连接广播新的配置信息，其他sentinel收到后依据配置纪元更大来更新主服务器信息。Sentinel保证第二个活性属性：一个可以相互通信的Sentinel集合会统一到一个拥有更高版本号的相同配置上。

