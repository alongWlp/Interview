# JVM相关面试题

**包括jvm内存模型，jvm线上问题排查**

**JVM面试总结**
## 基础知识面试总结

## 问题：怎么确认是垃圾？

引用计数法：通过在对象头中分配一个空间，来保存改对象被引用的次数。如果改对象被其他的对象所引用，则引用计数加1，如果删除对改对象的引用，则引用次数减1，当改引用次数为0的时候，那么改对象就会被回收。

```java
String m = new String("jack"); // m是jack字符串的引用
```

```java
m=null;//将m置为空，这时jack的引用次数就是0了，在引用计数里，意味着这块内存可以被回收了。
```

可达性分析算法：通过一些引用链（GC ROOTs)的对象做为起点，从这些节点向下探索，搜索走过的路径被称为(Reference Chain)，当一个对象到GC Roots没有任何引用链相连接的时候，则证明该对象是不可达的，就可以进行回收。

在Java中，可以作为GC Root的对象包括以下4种

1.虚拟机栈中引用的对象。

2.方法区中静态属性引用的对象。

3.方法区中常量引用的对象。

4.本地方法栈中，JNI引用的对象。

jvm结构


## 垃圾回收算法：

标记清除算法：先把内存中需要回收的对象进行标记，然后进行回收。这样容易产生内存碎片。


复制算法：将内存分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。

分代回收算法，java堆被分为新生代和老年代。在新生代中又划分了三个区域：Eden空间，To Survivor空间，From Survivor空间。


新创建的对象会被放在Eden区，当新生代发生GC后，会将Eden区和其中一个survivor区空间的内存复制到另一个survivor中，如果反复几次一直存活，此时对象会被移至老年代。

## 类加载机制

类的加载指的是，将类的.class二进制文件加载到内存中，将其放在运行时数据区的方法区内，然后在堆区上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。


JVM的类加载主要是通过ClassLoader及其子类来完成的，类的层次和加载顺序如下图所示。

1.Bootstarap ClassLoader 负责加载$JAVA_HOME中的jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。

2.Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。

3.App ClassLoader 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包。

4.Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。

加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载，就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

## JVM调优实际问题

GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。

1、查看gc日志，分析导致gc的原因

2、查看gc后对象的年龄，晋升老年代的情况

3、合理的分配新生代和老年代的大小

4、观察效果

5、重复3、4步骤

极少数据量的数据会晋升到老年代

gc发生的原因全部都是新生代内存不足

为什么增大新生代的大小可以减少gc整体时间？

更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本


## JVM内存结构

### 1 、新生代（Young Generation）：
大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。

新生代内又分三个区：一个Eden区，两个Survivor区（一般而言），大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。

### 2、老年代（Old Generation）：

在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。

### 3、永久代（Perm Generation）：

主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。


 1. Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。 
 2. Concurrent-mark并发标记，由前阶段标记过的绿色对象出发，所有可到达的对象都在本阶段中标记。 
 3. Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。 
 4. 并发清理，进行并发的垃圾清理。
 
 什么时候发生fullGC
 
 首先，什么时候可能会触发STW的Full GC呢？ 1. Perm空间不足； 2. CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）； 3. 统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间； 4. 主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。
